

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/szhBlogs.github.io/img/fluid.png">
  <link rel="icon" href="/szhBlogs.github.io/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="szh">
  <meta name="keywords" content="">
  
    <meta name="description" content="等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧">
<meta property="og:type" content="article">
<meta property="og:title" content="web前端面经">
<meta property="og:url" content="https://aixiaosu.github.io/szhBlogs.github.io/2023/06/09/chapters01/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aixiaosu.github.io/szhBlogs.github.io/img/bVcVYVs">
<meta property="og:image" content="https://aixiaosu.github.io/szhBlogs.github.io/img/bVcYTAr">
<meta property="article:published_time" content="2023-06-09T03:33:47.376Z">
<meta property="article:modified_time" content="2023-06-09T07:25:59.494Z">
<meta property="article:author" content="szh">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://aixiaosu.github.io/szhBlogs.github.io/img/bVcVYVs">
  
  
  
  <title>web前端面经 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/szhBlogs.github.io/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/szhBlogs.github.io/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/szhBlogs.github.io/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"aixiaosu.github.io","root":"/szhBlogs.github.io/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/szhBlogs.github.io/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/szhBlogs.github.io/js/utils.js" ></script>
  <script  src="/szhBlogs.github.io/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/szhBlogs.github.io/">
      <strong>与why结伴</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/szhBlogs.github.io/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/szhBlogs.github.io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/szhBlogs.github.io/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/szhBlogs.github.io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/szhBlogs.github.io/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/szhBlogs.github.io/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="web前端面经"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-09 11:33" pubdate>
          2023年6月9日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">web前端面经</h1>
            
            
              <div class="markdown-body">
                
                <p>等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！<br>等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！<br>等会,让我猜猜你此刻的想法,emmm,是不是想要跑路啦!哈哈哈!多大点事,年轻人就是要冲冲冲!接下来让我带你一起沉浸式的学习八股文吧！</p>
<p><strong>————————–面向对象—————————</strong><br>面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；这种思想是将数据作为第一位，这是对数据一种优化，操作起来更加的方便，简化了过程。</p>
<p>Js本身是没有class类型的，但是每个函数都有一个prototype属性，prototype指向一个对象，当函数作为构造函数时，prototype就起到类似于class的作用</p>
<p>面向对象有三个特点：<br>封装（隐藏对象的属性和实现细节，对外提供公共访问方式）;<br>继承（提高代码复用性，继承是多态的前提）;<br>多态（是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象）</p>
<p><strong>————————–普通函数和构造函数—————————</strong><br>区别:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22574487/article/details/102494531">https://blog.csdn.net/qq_22574487/article/details/102494531</a></p>
<p>1.构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写</p>
<p>2.调用方式不一样，普通函数直接调用，构造函数要用关键字new来调用</p>
<p>3.调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象</p>
<p>4.构造函数内部的this指向实例，普通函数内部的this指向调用函数的对象（如果没有对象调用，默认为window）</p>
<p>5.构造函数默认的返回值是创建的对象（也就是实例），普通函数的返回值由return语句决定</p>
<p>6.构造函数的函数名与类名相同</p>
<p><strong>————————–类继承—————————</strong><br><img src="/szhBlogs.github.io/img/bVcVYVs" srcset="/szhBlogs.github.io/img/loading.gif" lazyload><br>总结：<br>1.类中的构造器不是必须要写的，要对实例进行一些初始化的操作，如添加指定属性才写。<br>2.如果B类继承了A类，且B类中写了构造器，那么B类构造器中的Super是必须要调用的。<br>3.类中所定义的方法，都是放在了类的原型对象上，供实例去使用。<br><strong>————————–递归—————————</strong></p>
<p>理解:递归函数就是在函数体内调用本函数，即自己调用自己；<br>关键步骤:写出递归公式、找出终止条件；<br>注意：处理不当就会进入死循环；<br>应用：在特定的情况下使用 ，例如阶乘或者时间调用；<br>常见的面试题：<br>假如楼梯有n个台阶，每次可以走1个或2个台阶，请问走完这n个台阶有几种走法？<br>如何用递归思想实现深拷贝？<br>如何用递归思想实现数组的扁平化？<br>原文：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv5620926/">https://www.bilibili.com/read/cv5620926/</a><br>经典题：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mailyuan/p/13276323.html">https://www.cnblogs.com/mailyuan/p/13276323.html</a></p>
<p><strong>————————–原型|原型链—————————</strong><br>一、原型<br>①所有引用类型(函数，数组，对象)都有一个__proto__(隐式原型)属性，属性值是一个普通的对象<br>②所有函数都有一个prototype(原型&#x2F;显式原型)属性，属性值是一个普通的对象，注：原型是函数特有的，但箭头函数是没有的<br>③所有引用类型的__proto__属性指向它构造函数的prototype</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3];</span><br><span class="line">a.__proto__ === Array.prototype; // true</span><br></pre></td></tr></table></figure>
<p>理解：当打印一个对象,除了有该对象的值以外，而且会多一个__proto__ 属性,它就当前对象的原型。<br>原型是一个对象，打开对象发现有很多方法，其中有一个 constructor 属性，也就是构造函数,再打开 constructor 属性又可以发现有一个 prototype 属性，这个属性对应的值和先前我们在__proto__中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。</p>
<p>二、原型链<br>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型中的prototype(构造函数)上查找，如果还没有找到就会再到构造函数的prototype的__proto__中查找，如果没有则会返回null，这样一层一层向上查找就会形成一个链式结构，我们称为原型链</p>
<p>理解：其实原型链就是多个对象通过__proto__ 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent(month)&#123;</span><br><span class="line">    this.month = month;</span><br><span class="line">&#125;</span><br><span class="line">var child = new Parent(&#x27;Ann&#x27;);</span><br><span class="line">console.log(child.month); // Ann</span><br><span class="line">console.log(child.father); // undefined</span><br></pre></td></tr></table></figure>
<p>在child中查找某个属性时：<br>①一直往上层查找，直到到null还没有找到，则返回undefined<br>②Object.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; null</p>
<p>关于使用箭头函数的坑<br><img src="/szhBlogs.github.io/img/bVcYTAr" srcset="/szhBlogs.github.io/img/loading.gif" lazyload></p>
<p><strong>————————–promise—————————</strong><br>一、作用<br>  ①解决回调地狱,何为回调地狱:即函数嵌套使用，下一层回调函数依赖上一层回调函数的结果；<br>  ②支持多个并发的请求，获取并发请求中的数据;<br>  ③可以解决异步的问题(把异步变同步)，本身不能说promise是异步的<br>二、特点<br>1.所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。<br>2.对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending （进行中）、 fulfilled （已成功）和 rejected （已失败）。<br>3.只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>4.一旦状态改变，就不会再变，任何时候都可以得到这个结果。成功或者失败只要这两种情况其中一个发生，状态就凝固了，不会再变了，会一直保持这个结果，<br>这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>三、缺点<br>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。<br>如果不设置回调函数， Promise 内部抛出的错误，不会反应到外部。<br>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）<br>四、用法<br>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br>resolve 函数的作用是，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，在异步 操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数</p>
<p><strong>————————–this指向————————–</strong><br>&#x2F;&#x2F;this指向谁，跟函数在哪里定义没有关系，而是取决于被谁调用<br>四种this绑定：默认绑定、隐式绑定、显式绑定、关键字new绑定<br>说明：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82504422">https://zhuanlan.zhihu.com/p/82504422</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pssp/p/5216085.html">https://www.cnblogs.com/pssp/p/5216085.html</a><br>面试官：es6、箭头函数、this指向你是否了解<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45885731/article/details/120267545">https://blog.csdn.net/weixin_45885731/article/details/120267545</a></p>
<p><strong>————————–call|apply|bind——————-</strong><br>&#x2F;&#x2F;call、apply、bind方法是解决函数指向undefined的问题,三者通俗来说是改变this的指向，并拿到自己想要的值<br>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；<br>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；<br>call和apply后面接收的n个参数分别是字符串和数组的形式；其中bind和call接收参数的形式是一样的；<br>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。<br>如果call()和apply()的第一个参数是null或者undefined，那么this的指向就是全局变量，在浏览器里就是window对象。<br>说明：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pssp/p/5215621.html">https://www.cnblogs.com/pssp/p/5215621.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coco1s/p/4833199.html">https://www.cnblogs.com/coco1s/p/4833199.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010176097/article/details/80348447?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-4.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default--">https://blog.csdn.net/u010176097/article/details/80348447?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-4.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault--</a></p>
<p><strong>————————–浅拷贝和深拷贝——————-</strong><br>简单赋值例子：<br>var person &#x3D; ‘浅拷贝’;var person2 &#x3D; person ;person2 &#x3D; ‘深拷贝’;console.log(person,person2)&#x2F;&#x2F; ‘深拷贝’,’深拷贝’<br>赋值和浅拷贝的区别：赋值它其实只是复制了地址，从而会导致改变了一方的值，其他引用到该变量的值也会被改变，<br>而浅拷贝它会把所有的属性值拷贝到新的对象中，不会有这个问题。<br>浅拷贝的实现方法有：可以通过Object.assign 和 展开运算符 … 来实现浅拷贝 来解决这个问题，<br>但是问题来了，浅拷贝只会拷贝所有的属性值到新的对象中，但如果属性值是对象的话，拷贝的就是地址了，所以还会出现变量的值被覆盖的问题，<br>那么深拷贝就能解决浅拷贝的这个缺点：可以通过 JSON.parse(JSON.stringify(object)) 来解决。<br>但是该方法也是有局限性的：会忽略 undefined、会忽略 symbol、不能序列化函数、不能解决循环引用的对象<br>解决方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj)&#123;</span><br><span class="line">              //判断对象的类型</span><br><span class="line">            var newObj =  Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">            if(obj &amp;&amp; typeof obj == &quot;object&quot;)&#123;</span><br><span class="line">                  //迭代</span><br><span class="line">                  for(var key in obj)&#123;</span><br><span class="line">                        if(typeof obj[key] == &#x27;obj&#x27;)&#123;</span><br><span class="line">                          newObj[key] = deepCopy(obj[key])</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                          newObj[key]  = obj[key]</span><br><span class="line">                        &#125;     </span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return newObj</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>————————–数据类型————————–</strong><br>1、基本数据类型：Undefined、Null、Boolean、Number、String、Symbol<br>基本类型的变量是存放在栈区的（栈区指内存里的栈内存），栈区包括了 变量的标识符和变量的值。<br>2、引用类型：对象、数组、函数<br>（1）引用类型可以拥有属性和方法，并且是可以动态改变的。<br>（2）引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针</p>
<p><strong>————————–闭包————————–</strong><br>一、闭包<br>闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。<br>（1）要先明白全局作用域和函数作用域<br><strong>全局作用域</strong>:变量声明在全局，在函数内外都可以访问    <strong>函数作用域</strong>:变量声明在函数里，只能在函数内部可访问<br>（2）闭包就是能够读取其它函数内部变量的函数<br>（3）使用方法：在一个函数内部创建另一个函数<br>（4）最大用处有两个：读取其他函数的变量值，让这些变量始终保存在内存中<br>（5）缺点：会引起内存泄漏（引用无法被销毁，一直存在）<br>二、闭包特性<br>（1）基本的应用场景<br>　　1、保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。<br>　　2、在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。<br>（2）Javascript的垃圾回收机制<br>　　在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。<br>（3）例子，一个数组中有很多项数字，要获取该数组中指定数值区间的值<br><code>let arr = [2,12,11,3,4,5,9];</code><br>①想获取1到10的数字<br>②想获取2到8的数字<br>最初想到的解决方式是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = arr.filter(  i=&gt; &#123; return i&gt;= 1 &amp;&amp; i &lt;=10&#125;)</span><br><span class="line">let a = arr.filter(  i=&gt; &#123; return i&gt;= 2 &amp;&amp; i &lt;=8&#125;)</span><br></pre></td></tr></table></figure>
<p>但是要写两个方法来实现，很麻烦，所以可以引用闭包的特性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function between(a,b) &#123;</span><br><span class="line">  return function(v) &#123;</span><br><span class="line">       return v &gt;= a &amp;&amp; v &lt;=b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.filter(between(1,10))) //[2,3,4,5,9]</span><br><span class="line">console.log(arr.filter(between(2,8)))  //[2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>————————–作用域和作用域链————————–</strong><br>作用域：是指程序源代码中定义变量的区域，限定一个变量可访问范围的，作用域的本质是对象。JS采用的词法作用域，在书写代码的时候（定义函数的时候），作用域就已经确定好了。<br>在ES6环境下，包含3个作用域，全局作用域，函数作用域，快级作用域</p>
<p>作用域链：当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。<br>用途：保证对执行环境有权访问的所有变量和函数的有序访问。本质为执行上下文的scope属性，存储所有的变量，包括局部与全局，控制变量的使用顺序。</p>
<p>在es6中新增了一个块级作用域 , let 或 const 声明的变量只在 let 或 const 命令所在的代码块 {} 内有效，在 {} 之外不能访问。<br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  let a = 10</span><br><span class="line">&#125;</span><br><span class="line">console.log(a) //a is not defined</span><br><span class="line"></span><br><span class="line">for (let i in 100) &#123;</span><br><span class="line">  let b = 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(b) //b is not defined</span><br></pre></td></tr></table></figure>
<p>通过打印，a和b都报错is not defined，也就是访问不到这个变量。由于块级作用域是es6提出来的，我们在里面声明变量的时候也要使用es6定义变量的关键字let 和 const，而不应该使用 var 关键字。</p>
<p><strong>————————–事件委托————————–</strong><br>问题描述：大致就是一个商品列表，点击里面的每条商品记录就能进入对应商品详情页，点击每条记录里面的步进器就可以对商品的数量进行修改，我给外层的DOM节点绑定了一个点击事件，用来触发跳转进入商品详情页的动作，步进器我用的是Vant UI的一个组件，绑定了一个change事件，这时候就会出现一个问题就是，每当我点击步进器对商品数量进行修改的时候，就会触发我绑定在外层父DOM节点的点击事件</p>
<p>定义：事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点（事件冒泡），并且父节点可以通过事件对象获取到目标节点（事件捕获），因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗，也是常见的JS性能优化的一个点。</p>
<p>Vue.js 为 v-on 提供了 事件修饰符（阻止事件冒泡）：<br>.stop 阻止事件继续传播<br>.prevent 阻止标签默认行为<br>.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理<br>.self 只当在 event.target 是当前元素自身时触发处理函数<br>.once 事件将只会触发一次<br>.passive 告诉浏览器你不想阻止事件的默认行为</p>
<p><strong>————————–网站性能优化————————–</strong><br>&#x2F;&#x2F;恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。<br>用户角度:优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。<br>服务商角度:优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</p>
<p>前端优化的途径有很多，可以分为两类，<br>第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等;<br>第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等.<br>一、页面级优化</p>
<ol>
<li>JavaScript 压缩和模块打包</li>
<li>按需加载资源</li>
<li>在使用 DOM 操作库时用上 array-ids</li>
<li>缓存</li>
<li>启用 HTTP&#x2F;2</li>
<li>应用性能分析</li>
<li>使用负载均衡方案</li>
<li>为了更快的启动时间考虑一下同构</li>
<li>使用索引加速数据库查询</li>
<li>使用更快的转译方案</li>
<li>避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</li>
<li>用于未来的一个建议：使用 service workers + 流</li>
<li>图片编码优化<br>详细说明：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33951761/article/details/88755467?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.no_search_link">https://blog.csdn.net/weixin_33951761/article/details/88755467?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.no_search_link</a></li>
</ol>
<p><strong>————————–Vue打包————————–</strong><br>打包命令npm run build</p>
<p>vue项目打包页面出现空白和报错</p>
<p>详细解析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24882601/article/details/90479832">https://blog.csdn.net/qq_24882601/article/details/90479832</a></p>
<p>概念：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhishiqi15836010823/article/details/100569635">https://blog.csdn.net/zhishiqi15836010823/article/details/100569635</a></p>
<p><strong>————————–跨域————————–</strong><br>&#x2F;&#x2F;当我们请求一个接口的时候，出现如：Access-Control-Allow-Origin 字眼的时候说明请求跨域了<br>&#x2F;&#x2F;造成跨域，是因为浏览器的同源策略问题，如下面几种情况：<br>①想获取另一台服务器的数据，但各自的域名不一致，导致跨域访问不了<br>②由于使用一台服务器的压力特别大，所以会分出好几个的服务器来一起承担，但会导致访问的服务器的域名都不一样，所以也会造成跨域</p>
<p>&#x2F;&#x2F;同源策略，是浏览器的一种安全策略，发送请求一定要同源<br>同源：协议、域名、端口号，必须完全相同。违背同源策略就是跨域</p>
<p>| url | 是否符合同源 |差别|<br>| —– | —– |<br>| <a target="_blank" rel="noopener" href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a> | 符合 |只有路径不同|<br>| <a target="_blank" rel="noopener" href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a> | 符合 |只有路径不同|<br>| <a target="_blank" rel="noopener" href="https://store.company.com/secure.html">https://store.company.com/secure.html</a> | 不符 |协议不同|<br>| <a target="_blank" rel="noopener" href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a> | 不符 |端口不同(默认端口是80)|<br>| <a target="_blank" rel="noopener" href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a> | 不符 |域名&#x2F;主机不同|<br>&#x2F;&#x2F;几种常用的解决方案:<br>  1)jsonp<br>  2)nginx反向代理<br>  3)配置vue-cli生成的文件实现代理<br>  4)后端设置CORS来解决跨域<br>注: 二、三两种都是服务器代理,因为跨域是浏览器的跨域限制,但是服务器不存在跨域问题,所以可以由服务器请求所要访问的资源然后再返回给客户端</p>
<p>&#x2F;&#x2F;详细说明：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020489582">https://segmentfault.com/a/1190000020489582</a><br>&#x2F;&#x2F;vue解决跨域:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lihaohua/p/12372267.html">https://www.cnblogs.com/lihaohua/p/12372267.html</a></p>
<p><strong>————————–正向|反向|nginx|负载均衡————————–</strong><br>&#x2F;&#x2F;正向代理<br>Nginx根据接收到的参数，判断出应该到哪个地址，发送什么数据，然后根据这些获取数据，获取后返回给客户端</p>
<p>&#x2F;&#x2F;反向代理<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，<br>并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。<br>简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。</p>
<p>&#x2F;&#x2F;负载均衡<br>负载均衡也是 Nginx 常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。 而 Nginx 目前支持自带3种负载均衡策略，还有2种常用的第三方策略。 </p>
<p>nginx反向代理部署vue项目(history模式)的方法<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mmzuo-798/p/10871750.html%EF%BC%8C">https://www.cnblogs.com/mmzuo-798/p/10871750.html，</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/libo222/article/details/51974164?utm_source=blogxgwz9">https://blog.csdn.net/libo222/article/details/51974164?utm_source=blogxgwz9</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020596883">https://segmentfault.com/a/1190000020596883</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/daybreak1209/article/details/51549031">https://blog.csdn.net/daybreak1209/article/details/51549031</a></p>
<p>了解反向代理<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903818010820621">https://juejin.cn/post/6844903818010820621</a></p>
<p><strong>————————–nginx的使用————————–</strong><br>启动nginx服务，启动时会一闪而过是正常的<br>start nginx</p>
<p>查看任务进程是否存在，dos或打开任务管理器都行<br>tasklist &#x2F;fi “imagename eq nginx.exe”</p>
<p>快速停止<br>nginx -s stop</p>
<p>&#x2F;&#x2F;重新加载nginx<br>nginx -s reload                </p>
<p>完整有序的关闭<br>nginx -s quit</p>
<p><strong>————————–ES6————————–</strong><br>沅一峰文章：<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async">https://es6.ruanyifeng.com/#docs/async</a><br>1、何为异步操作<br>同步 指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。<br>异步 指的是每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>2.异步的使用背景<br>首先js是单线程的语言，即同一时间只能做做一件事。那Js如何实现异步的，异步和单线程不是自相矛盾吗？其实，单线程和异步确实不能同时成为一个语言的特性。js选择了成为单线程的语言，所以它本身不可能是异步的，但js的宿主环境（比如浏览器，Node）是多线程的，宿主环境通过某种方式（事件驱动，下文会讲）使得js具备了异步的属性。</p>
<p>浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：javascript引擎线程，UI渲染线程，浏览器事件触发线程。</p>
<p>1.javascript引擎线程是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。</p>
<p>2.UI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起，UI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p>3.事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>web前端面经</div>
      <div>https://aixiaosu.github.io/szhBlogs.github.io/2023/06/09/chapters01/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>szh</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/szhBlogs.github.io/2023/06/09/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/szhBlogs.github.io/js/events.js" ></script>
<script  src="/szhBlogs.github.io/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/szhBlogs.github.io/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/szhBlogs.github.io/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/szhBlogs.github.io/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
